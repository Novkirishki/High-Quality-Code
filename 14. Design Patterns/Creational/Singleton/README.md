# Singleton Design Pattern

### Motivation

Singleton шаблонът се използва когато искаме да имаме само една инстанция на даден клас. Най-често се прилага, когато искаме да имаме централизирано управление на вътрешни или външни ресурси, като ни дава глобална точка на достъп до тях. Той е един от най-лесните за прилагане шаблони, защото представлява само един клас, който има за цел да се самоинстанциализира, да не допуска повече от една инстанция и да осигурява глобален достъп до нея.

### Intent
	*	Осигурява създаването на единствена инстанция
	*	Осигурява глобален достъп до обекта

### Implementation & Structure

Имплементацията включва статично поле в Singleton класа, private конструктор и статичен публичен метод, който да връща референция към статичното поле.

![Singleton inplementation](singleton_implementation.gif)

### Applicability & Examples

Както вече беше споменато по-горе Singleton се прилага, когато искаме да имаме една инстанция от клас и тя да е достъпна глобално. Примери: 
	*	Logger - често са singleton-и, за да се избегне извикването на нов обект при всяко логване
	*	Достъп до споделени ресурси 
	*	Factory-та - ако имаме приложение, което използва factory pattern, то обикновено factory-то е singleton

### Problems & Solutions

	*	Имплементация в многонишково приложение - възможно е две или повече различни нишки по едно и също време да достъпват singleton обекта или да се инициализират повече от една инстанции(при lazy loading), ако няколко нишки едновременно в началото поискат обекта. Тези проблеми се решават по два начина: 
		*	lazy loading със двоен lock механизъм 
		*	ранна инициализация още при създаването на класа(може да се инициализира обект, който да не бъде използван никога)
	*	Сериализация - когато Singleton имплементира Serializable интерфейс, трябва да имплементира readResolve метода(Java). В противен случай при сериализация и десериализация ще има няколко инстанции на Singleton класа.
	*	Наследяване(protected конструктор) - наследяването на Singleton не е добра идея. Така обектът може да бъде инстанциран от клас наследник. Също така методът Singleton.getInstance() трябва да бъде променен в кода на  newSingleton.getInstance(), където newSingleton е наследникът. Както знаем това е в противоречие с един от основните принципи на ООП.
